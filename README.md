# How I generated the longest ever xmr vanity address
## Preface
I became interested in vanity addresses when I was browsing around on the dark web. I noticed that most of the onion services I visited contained the name of the service inside of the onion address. For example, duckduckgo provides an onion service at: https://duckduckgogg42xjoc72x3sjasowoarfbgcmvfimaftt6twagswzczad.onion. I figured that these addresses probably had a small field at the beginning for a name followed by relevant cryptographic data. To my suprise, there was no such field, and these addresses are nearly indistingishable from being totally random, being generated as a SHA-1 hash of the private key for the serice. At the same time, I was learning about proof-of-work blockchains, and I realized the process to create one of these onion addresses was no different than the process of generating cryptographic proof-of-work as described in the Bitcoin whitepaper. I have no plans to run an onion service, but I thought it might be cool to have a stylized BTC, LTC, or XMR address. Such addresses, I learned, are called "vanity addresses"

## Monero addresses
Monero addresses are somewhat unique compared to other crypto addresses, because they consist of 2 keys instead of just 1: these keys are called the **public view key** and the **public spend key** and are derived from the private spend and view key using a cryptographic elliptic curve algorithm. After finding out monero addresses are actually 2 keys, I realized that I could generate significantly longer vanity addresses at the junction between these 2 keys. This would allow me to easily beat any existing length records for vanity addresses, while unfortunately precluding vanity strings at the beginning of the address where they are most visible. Generating 2 halves of the vanity address seperately effectively square roots the search space, making searches that would normally take hundreds of thousands of years on average possible to do in just minutes.

## Implementation
Monero addresses are implemented in a somewhat obtuse way. The first byte is a "network byte" which specifies whether an address is a part of the Mainnet or testnet and whether or not it is a "subaddress," which is a seperate address corresponding to a different set of private keys derived deterministically from the main private keys and an index. Following this is the 32-byte public spend key, then the 32-byte public view key, and finally a 4-byte checksum. Simple enough, but the conversion to its typical base58 representation is kind of a pain. The address is divided front the back into 8-byte chunks, each of which is treated as a big-endian integer, with the 5 remaining bytes also given the same treatment; finally, each of these integers is converted to base 58 representation, with the most significant digit first (same as out typical base 10 representation). Each 8-byte section becomes an 11-digit base 58 number and the 5-byte section becomes a 7-digit base 58 number, leading to an overall 95-character address. The most notable quirk this produces is that each 11-digit base58 number is limited to the max 64 bit integer, which can be somewhat limiting when you realize that the first character of every 11-character set can never be one of the last 16 characters in the encoding, which are all lowercase letters. In the creation of vanity addresses, we are concerned with 2 of these 11-digit sections. One of them is made from byte 23 to byte 30 of the spend key, and one of byte 31 of the spend key and bytes 0-6 of the view key. Which, of course, means that when generqting the spend key we will need to make sure it is compatible with the spend key. We can do this by just making a decent approximation of the needed byte using the desired vanity digits of the view key, and filtering for that byte along with the first half of the vanity string when generating the spend key.
